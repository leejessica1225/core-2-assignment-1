<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Draggable Card Deck</title>
  <style>
    :root{
      --card-w: 180px;
      --card-h: 250px;
      --radius: 18px;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: #0b0e12;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none; /* pointer drag 안정 */
    }

    /* 배경(영상 느낌 나게: 어둡고 바닥 질감 비슷하게) */
    .bg {
      position: fixed;
      inset: 0;
      background:
        radial-gradient(1200px 500px at 55% 20%, rgba(255,255,255,0.08), transparent 60%),
        radial-gradient(900px 450px at 40% 35%, rgba(255,255,255,0.05), transparent 65%),
        linear-gradient(180deg, #07090c 0%, #0b0e12 55%, #0c1411 100%);
      filter: saturate(0.95) contrast(1.05);
    }
    .floor {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      height: 34%;
      background:
        radial-gradient(900px 220px at 50% 0%, rgba(0,0,0,0.35), transparent 70%),
        linear-gradient(180deg, rgba(46, 96, 55, 0.65), rgba(21, 60, 31, 0.85));
      opacity: 0.9;
      filter: blur(0.2px);
    }

    /* 덱을 올려둘 무대 */
    .stage {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      perspective: 900px;
      perspective-origin: 50% 45%;
    }

    /* 덱: 영상처럼 살짝 왼쪽에 두고 싶으면 translateX만 조절 */
    .deck {
      position: relative;
      width: calc(var(--card-w) + 220px);
      height: calc(var(--card-h) + 160px);
      transform: translateX(-60px) translateY(20px);
    }

    .card {
      position: absolute;
      width: var(--card-w);
      height: var(--card-h);
      left: 50%;
      top: 50%;
      transform-style: preserve-3d;
      border-radius: var(--radius);
      transform-origin: 50% 85%;
      box-shadow:
        0 22px 50px rgba(0,0,0,0.55),
        0 6px 14px rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.18);
      overflow: hidden;
      will-change: transform;
      backface-visibility: hidden;
    }

    /* 카드 표면 텍스처(원하면 이미지로 교체) */
    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(2px 2px at 30% 40%, rgba(0,0,0,0.22), transparent 55%),
        radial-gradient(2px 2px at 60% 55%, rgba(0,0,0,0.18), transparent 55%),
        radial-gradient(2px 2px at 50% 30%, rgba(0,0,0,0.16), transparent 55%),
        linear-gradient(135deg, rgba(255,255,255,0.35), rgba(255,255,255,0.05));
      opacity: 0.75;
      mix-blend-mode: overlay;
      pointer-events: none;
    }

    /* 카드 종류별(영상처럼 다른 패턴/톤) */
    .skin-cream {
      background:
        radial-gradient(10px 10px at 25% 35%, rgba(0,0,0,0.25), transparent 55%),
        radial-gradient(8px 8px at 55% 52%, rgba(0,0,0,0.22), transparent 55%),
        radial-gradient(9px 9px at 65% 30%, rgba(0,0,0,0.18), transparent 55%),
        linear-gradient(180deg, #e8dcc6 0%, #d7c6aa 100%);
    }
    .skin-gray {
      background:
        radial-gradient(9px 9px at 25% 35%, rgba(0,0,0,0.23), transparent 55%),
        radial-gradient(8px 8px at 60% 55%, rgba(0,0,0,0.20), transparent 55%),
        linear-gradient(180deg, #a3a9a6 0%, #7f8784 100%);
    }
    .skin-dark {
      background: linear-gradient(180deg, #2a2f33 0%, #202427 100%);
    }

    /* 뒤 카드(덱 모양) 기본 그림자 좀 약하게 */
    .card.is-back {
      box-shadow:
        0 18px 40px rgba(0,0,0,0.45),
        0 5px 12px rgba(0,0,0,0.25);
      filter: saturate(0.95);
    }

    /* 맨 앞 카드만 드래그 가능 */
    .card.is-front {
      cursor: grab;
    }
    .card.is-front:active {
      cursor: grabbing;
    }

    /* 접근성: 모션 줄이기 */
    @media (prefers-reduced-motion: reduce) {
      .card { transition: none !important; }
    }
  </style>
</head>

<body>
  <div class="bg"></div>
  <div class="floor"></div>

  <div class="stage">
    <div class="deck" id="deck"></div>
  </div>

<script>
(() => {
  const deckEl = document.getElementById("deck");

  // 영상처럼 5장 정도로 시작
  const skins = ["skin-dark", "skin-cream", "skin-gray", "skin-dark", "skin-cream"];

  // 덱(뒤 카드) 부채꼴 세팅 값 (영상 느낌: 위쪽으로 살짝 올라가며 좌측으로 모임)
  // index 0이 "맨 앞(드래그 카드)"
  const FAN = [
    { x: 0,   y: 26,  rz: 0,   z: 50 },   // front
    { x: -54, y: -68, rz: -18, z: 40 },
    { x: -84, y: -86, rz: -26, z: 30 },
    { x: -112,y: -98, rz: -34, z: 20 },
    { x: -138,y: -106,rz: -42, z: 10 },
  ];

  // 드래그/스와이프 감도
  const ROTATE_Z_MAX = 18;     // 드래그 시 z회전 최대
  const ROTATE_Y_MAX = 26;     // 좌우 기울기
  const ROTATE_X_MAX = 10;     // 위아래 기울기
  const SWIPE_X = 120;         // 이 정도 넘기면 날려버림
  const FLY_OUT_X = 520;       // 날아갈 거리
  const FLY_OUT_Y = -220;

  // 스무딩(스프링 느낌)
  const SPRING = 0.14;         // 값 올리면 더 빨리 따라옴
  const DAMP   = 0.80;

  // state
  let cards = [];              // DOM nodes
  let order = skins.map((s, i) => ({ id: i, skin: s })); // 덱 순서(앞이 0)
  let pointerDown = false;
  let startX = 0, startY = 0;
  let dragX = 0, dragY = 0;    // 목표값
  let curX = 0, curY = 0;      // 현재값(스프링 보간)
  let velX = 0, velY = 0;
  let animatingOut = false;

  function createCards() {
    deckEl.innerHTML = "";
    cards = order.map((item, idx) => {
      const div = document.createElement("div");
      div.className = `card ${item.skin}`;
      deckEl.appendChild(div);
      return div;
    });
    layout();
    bindFront();
  }

  function bindFront() {
    cards.forEach(c => c.classList.remove("is-front", "is-back"));
    cards.forEach((c, i) => c.classList.add(i === 0 ? "is-front" : "is-back"));

    const front = cards[0];
    front.addEventListener("pointerdown", onDown, { passive: false });
  }

  function unbindFront() {
    const front = cards[0];
    if (!front) return;
    front.removeEventListener("pointerdown", onDown);
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function layout() {
    // 뒤 카드들은 FAN에 따라 고정 배치
    cards.forEach((card, i) => {
      const f = FAN[Math.min(i, FAN.length - 1)];
      const tx = `translate(-50%, -50%) translate(${f.x}px, ${f.y}px)`;
      const rz = `rotateZ(${f.rz}deg)`;
      const tz = `translateZ(${f.z}px)`;
      // 기본적으로 살짝 기울여서 3D 느낌
      const base3d = `rotateX(7deg) rotateY(-10deg)`;

      card.style.transition = animatingOut ? "none" : "transform 420ms cubic-bezier(.18,.9,.2,1)";
      card.style.transform = `${tx} ${tz} ${base3d} ${rz}`;
      card.style.zIndex = String(100 - i);
      card.style.opacity = "1";
    });
  }

  function renderFrontWithDrag() {
    const front = cards[0];
    if (!front) return;

    // 드래그량을 카드 회전에 매핑
    const nx = clamp(curX / 220, -1, 1);
    const ny = clamp(curY / 180, -1, 1);

    const rz = nx * ROTATE_Z_MAX;
    const ry = nx * ROTATE_Y_MAX;
    const rx = -ny * ROTATE_X_MAX;

    // 영상처럼: 아래쪽에 있다가 드래그하면 살짝 떠오르는 느낌
    const lift = Math.min(26, Math.abs(curX) * 0.08 + Math.abs(curY) * 0.04);

    const base = FAN[0];
    const tx = `translate(-50%, -50%) translate(${base.x + curX}px, ${base.y + curY - lift}px)`;
    const tz = `translateZ(${base.z + 90}px)`; // 앞카드는 더 앞으로
    const tilt = `rotateX(${7 + rx}deg) rotateY(${-10 + ry}deg) rotateZ(${rz}deg)`;

    front.style.transition = "none";
    front.style.transform = `${tx} ${tz} ${tilt}`;
  }

  function tick() {
    // 스프링 보간으로 curX/Y가 dragX/Y를 따라감 (매우 smooth)
    const ax = (dragX - curX) * SPRING;
    const ay = (dragY - curY) * SPRING;

    velX = (velX + ax) * DAMP;
    velY = (velY + ay) * DAMP;

    curX += velX;
    curY += velY;

    renderFrontWithDrag();
    requestAnimationFrame(tick);
  }

  function onDown(e) {
    if (animatingOut) return;
    e.preventDefault();
    pointerDown = true;
    startX = e.clientX;
    startY = e.clientY;

    unbindFront();
    window.addEventListener("pointermove", onMove, { passive: false });
    window.addEventListener("pointerup", onUp, { passive: false });
    window.addEventListener("pointercancel", onUp, { passive: false });
  }

  function onMove(e) {
    if (!pointerDown) return;
    e.preventDefault();

    const dx = e.clientX - startX;
    const dy = e.clientY - startY;

    // 목표 드래그값(부드럽게 따라오게 tick이 처리)
    dragX = clamp(dx, -280, 280);
    dragY = clamp(dy, -220, 220);
  }

  function flyOut(direction) {
    animatingOut = true;
    const front = cards[0];
    if (!front) return;

    const sign = direction;
    front.style.transition = "transform 520ms cubic-bezier(.14,.9,.2,1), opacity 520ms cubic-bezier(.2,1,.2,1)";
    front.style.opacity = "0";

    const base = FAN[0];
    const outX = base.x + sign * FLY_OUT_X;
    const outY = base.y + FLY_OUT_Y;

    front.style.transform =
      `translate(-50%, -50%) translate(${outX}px, ${outY}px) translateZ(240px)
       rotateX(10deg) rotateY(${sign * 46}deg) rotateZ(${sign * 34}deg)`;

    front.addEventListener("transitionend", () => {
      // 순서: 맨 앞을 맨 뒤로 보내고 재배치
      const first = order.shift();
      order.push(first);

      // 드래그 값 리셋
      dragX = dragY = 0;
      curX = curY = 0;
      velX = velY = 0;

      animatingOut = false;
      createCards();
    }, { once: true });
  }

  function snapBack() {
    // 목표값을 0으로 두면 tick()이 스프링으로 돌아감
    dragX = 0;
    dragY = 0;

    // 뒤 카드들은 다시 layout transition으로 안정감 있게
    layout();
    bindFront();
  }

  function onUp(e) {
    pointerDown = false;
    window.removeEventListener("pointermove", onMove);
    window.removeEventListener("pointerup", onUp);
    window.removeEventListener("pointercancel", onUp);

    // 스와이프 판정
    if (Math.abs(dragX) > SWIPE_X) {
      const dir = dragX > 0 ? 1 : -1;
      // 뒤 카드 재배치(다음 카드가 살짝 앞으로 준비되는 느낌)
      layout();
      flyOut(dir);
      return;
    }

    snapBack();
  }

  // init
  createCards();
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>

