<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Card Deck (Infinite Swipe)</title>
  <style>
    :root{
      --card-w: 180px;
      --card-h: 250px;
      --radius: 18px;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: #000;       
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    .stage {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      perspective: 900px;
      perspective-origin: 50% 45%;
    }

    .deck {
      position: relative;
      width: calc(var(--card-w) + 220px);
      height: calc(var(--card-h) + 160px);
      transform: translateX(-60px) translateY(20px);
    }

    .card {
      position: absolute;
      width: var(--card-w);
      height: var(--card-h);
      left: 50%;
      top: 50%;
      transform-style: preserve-3d;
      border-radius: var(--radius);
      transform-origin: 50% 85%;
      border: 1px solid rgba(255,255,255,0.18);
      overflow: hidden;
      will-change: transform, opacity;
      backface-visibility: hidden;

      box-shadow:
        0 22px 50px rgba(0,0,0,0.75),
        0 6px 14px rgba(0,0,0,0.55);
    }

    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(2px 2px at 30% 40%, rgba(0,0,0,0.22), transparent 55%),
        radial-gradient(2px 2px at 60% 55%, rgba(0,0,0,0.18), transparent 55%),
        linear-gradient(135deg, rgba(255,255,255,0.35), rgba(255,255,255,0.05));
      opacity: 0.75;
      mix-blend-mode: overlay;
      pointer-events: none;
    }

    .skin-cream { background: linear-gradient(180deg, #e8dcc6 0%, #d7c6aa 100%); }
    .skin-gray  { background: linear-gradient(180deg, #a3a9a6 0%, #7f8784 100%); }
    .skin-dark  { background: linear-gradient(180deg, #2a2f33 0%, #202427 100%); }

    .card { pointer-events: none; }
    .card.is-front { pointer-events: auto; cursor: grab; }
    .card.is-front:active { cursor: grabbing; }
  </style>
</head>

<body>
  <div class="stage">
    <div class="deck" id="deck"></div>
  </div>

<script>
(() => {
  const deckEl = document.getElementById("deck");

  const skins = ["skin-dark","skin-cream","skin-gray","skin-dark","skin-cream"];

  const FAN = [
    { x: 0,   y: 26,   rz: 0,   z: 50 },   
    { x: -54, y: -68,  rz: -18, z: 40 },
    { x: -84, y: -86,  rz: -26, z: 30 },
    { x: -112,y: -98,  rz: -34, z: 20 },
    { x: -138,y: -106, rz: -42, z: 10 },
  ];

  const ROTATE_Z_MAX = 18;
  const ROTATE_Y_MAX = 26;
  const ROTATE_X_MAX = 10;

  const SWIPE_X = 120;
  const FLY_OUT_X = 520;
  const FLY_OUT_Y = -220;

  const SPRING = 0.14;
  const DAMP   = 0.80;

  let order = skins.map((skin, i) => ({ id: i, skin }));
  let cardEls = [];                
  let dragging = false;
  let animatingOut = false;

  let startX = 0, startY = 0;
  let dragX = 0, dragY = 0;        
  let curX = 0, curY = 0;           
  let velX = 0, velY = 0;

  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

  function build() {
    deckEl.innerHTML = "";
    cardEls = order.map((item) => {
      const d = document.createElement("div");
      d.className = `card ${item.skin}`;
      deckEl.appendChild(d);
      return d;
    });
    renderDeck(true);
  }

  function renderDeck(first=false) {
    cardEls.forEach((el, i) => {
      el.classList.toggle("is-front", i === 0);

      const f = FAN[Math.min(i, FAN.length - 1)];
      const base3d = `rotateX(7deg) rotateY(-10deg)`;
      const tx = `translate(-50%, -50%) translate(${f.x}px, ${f.y}px)`;
      const tz = `translateZ(${f.z}px)`;
      const rz = `rotateZ(${f.rz}deg)`;

      el.style.opacity = "1";
      el.style.zIndex = String(100 - i);
      el.style.transition = first ? "none" : "transform 420ms cubic-bezier(.18,.9,.2,1)";
      el.style.transform = `${tx} ${tz} ${base3d} ${rz}`;
    });
  }

  function renderFrontDrag() {
    const front = cardEls[0];
    if (!front) return;

    const nx = clamp(curX / 220, -1, 1);
    const ny = clamp(curY / 180, -1, 1);

    const rz = nx * ROTATE_Z_MAX;
    const ry = nx * ROTATE_Y_MAX;
    const rx = -ny * ROTATE_X_MAX;

    const lift = Math.min(26, Math.abs(curX) * 0.08 + Math.abs(curY) * 0.04);

    const base = FAN[0];
    const tx = `translate(-50%, -50%) translate(${base.x + curX}px, ${base.y + curY - lift}px)`;
    const tz = `translateZ(${base.z + 90}px)`;
    const tilt = `rotateX(${7 + rx}deg) rotateY(${-10 + ry}deg) rotateZ(${rz}deg)`;

    front.style.transition = "none";
    front.style.transform = `${tx} ${tz} ${tilt}`;
  }

  function tick() {
    const ax = (dragX - curX) * SPRING;
    const ay = (dragY - curY) * SPRING;

    velX = (velX + ax) * DAMP;
    velY = (velY + ay) * DAMP;

    curX += velX;
    curY += velY;

    if (dragging && !animatingOut) renderFrontDrag();
    requestAnimationFrame(tick);
  }

  function snapBack() {
    dragX = 0; dragY = 0;
    renderDeck(false);
  }

  function flyOut(dir) {
    animatingOut = true;
    const front = cardEls[0];
    if (!front) return;

    front.style.transition =
      "transform 520ms cubic-bezier(.14,.9,.2,1), opacity 520ms cubic-bezier(.2,1,.2,1)";
    front.style.opacity = "0";

    const base = FAN[0];
    const outX = base.x + dir * FLY_OUT_X;
    const outY = base.y + FLY_OUT_Y;

    front.style.transform =
      `translate(-50%, -50%) translate(${outX}px, ${outY}px) translateZ(240px)
       rotateX(10deg) rotateY(${dir * 46}deg) rotateZ(${dir * 34}deg)`;

    front.addEventListener("transitionend", () => {
      const first = order.shift();
      order.push(first);

      dragX = dragY = 0;
      curX = curY = 0;
      velX = velY = 0;

      animatingOut = false;

      build();
    }, { once: true });
  }

  deckEl.addEventListener("pointerdown", (e) => {
    if (animatingOut) return;

    const front = cardEls[0];
    if (!front) return;

    if (e.target !== front) return;

    dragging = true;
    startX = e.clientX;
    startY = e.clientY;

    front.setPointerCapture?.(e.pointerId);
  });

  window.addEventListener("pointermove", (e) => {
    if (!dragging || animatingOut) return;

    const dx = e.clientX - startX;
    const dy = e.clientY - startY;

    dragX = clamp(dx, -280, 280);
    dragY = clamp(dy, -220, 220);
  }, { passive: true });

  window.addEventListener("pointerup", () => {
    if (!dragging || animatingOut) return;
    dragging = false;

    if (Math.abs(dragX) > SWIPE_X) {
      const dir = dragX > 0 ? 1 : -1;
      renderDeck(false);
      flyOut(dir);
      return;
    }
    snapBack();
  });

  build();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>

